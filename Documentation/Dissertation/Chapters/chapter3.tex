\chapter{Implementation}

%The implementation should look at any issues you encountered as you tried to implement your design. During the work, you might have found that elements of your design were unnecessary or overly complex; perhaps third party libraries were available that simplified some of the functions that you intended to implement. If things were easier in some areas, then how did you adapt your project to take account of your findings?
%
%It is more likely that things were more complex than you first thought. In particular, were there any problems or difficulties that you found during implementation that you had to address? Did such problems simply delay you or were they more significant?

%You can conclude this section by reviewing the end of the implementation stage against the planned requirements. 
	
\section{Data Downloading}
\label{sec:imp_data_download}
%discuss data downloader implementation, discussing file name pattern and challenges with that, as well as %difficulties with storage as dataset is large
One of the first parts of the system to be implemented was the Data Downloader. This was done first in order to get the full dataset downloaded as fast as possible, and also as a form of Python practice.

As mentioned in Section \ref{sec:des_data_downloader}, the files that needed to be downloaded from the online archive had a specific format that made finding all the files required easier. Each series had a specific URL, and all files for that series would be stored as children of that URL in zip files. The naming pattern for the files was as follows:

\textbf{S\emph{s}V\emph{vvvv}P\emph{p}.zip}

where \emph{s} is the series from 1 to 6, \emph{vvvv} is 4 digits representing the volume of the series, starting at 0001, the max value depending on which series it is a part of, and \emph{p} is a part number, as some files were split into multiple parts. This could be zero, if the file is not split, or a one or two if it has been split. For instance \emph{S6V0141P1.zip} would represent the \emph{1st} part of the \emph{141st} volume in series \emph{6}.

There was one difference to this pattern, discovered during development. Series 5 of Hansard was separated into records for the \emph{House of Commons} and the \emph{House of Lords}. For these, the letter \emph{C} or \emph{L} was added before the V to differentiate the two series. Afterwards, series 6 also contained the letter \emph{C} to show that it was also only for the house of commons. So, for Series 6, volume 141, part 1, the file format would actually be \emph{S6CV0141P1.zip}.

\subsection{Online Connection}
\label{sec:imp_online_connect}
Python has a commonly used library for HTTP connections called \href{http://docs.python-requests.org/en/master/}{\emph{Requests}}. It provides an API (\emph{Application Programming Interface}) allowing easy connection to a provided URL, simply by providing a URL. Using this API, the downloader can check to see if a file exists, using the code snippet Algorithm \ref{lst:downloader_snippet}.

\begin{lstlisting}[float=ht,
				   caption={Snippet of the Downloader Code},
				   label={lst:downloader_snippet}]
for i in range(0, 100):  # change depending on how many files it looks like exist
    for j in range(0, 4):  # just to make sure. Not seen any files with P3 at the end but you never know
        temp_url = '{}{}/{}'.format(url_base, url_add[series-1], file_name_format.format(series, i, j))
        print("Checking: {}".format(file_name_format.format(series, i, j)))
        r = requests.get(temp_url)
        status = r.headers['content-type']
# if the zip file exists, the type will appear like this:
        if status == 'application/zip; charset=utf-8':  
            print("FILE FOUND")
            zip_ref = zipfile.ZipFile(io.BytesIO(r.content))
            zip_ref.extractall(save_loc)  # extract the file
            zip_ref.close()

        else:  # if the zip file doesn't exist an error page is returned instead
            print("FILE NOT FOUND")
\end{lstlisting}

Effectively, this code snippet loops through the files following the described pattern, and gets the status of the constructed URL. the \emph{header} part returns a string that describes the type of file returned, as if the file does not exist, it still returns a 404 error page rather than not returning anything. If the file does exist, however, it returns a string that says it is a ZIP file type (\emph{"application/zip"}).

If the file does exist, the downloader also makes use of a library called \emph{zipfile}, which allows it to handle zip files internally. It can then extract the data file from the compressed zip file, and save it to the designated directory on the local machine.

\subsection{Dataset Size}
\label{sec:imp_dataset_size}

The total Historical Hansard Dataset that was downloaded by the project is \emph{14.4GB}, and consists of \emph{2503} files, demonstrating the need for the automated downloading. Due to this size, the dataset could not be saved to the University file system, and so was saved to an external hard drive instead. This meant that some parts of the later development were slowed due to the USB 3 connection used by said hard drive. 

\section{Data Parsing}
\label{sec:imp_data_parse}
%discuss experimentation with how to extract data from original dataset. discuss change made to format of parsed data part way through to make it easier to annoate.
During development of the system, the Data Parser and associated methods were where the most time was spent, due to many unforeseen complications.
 
\subsection{Name Recognition and Disambiguation}
\label{sec:imp_name_disamb}
%here discuss difficulties in name disambiguation. discuss attempted methods of using NLTKs named entity %thing and the implemented regex solution. Discuss how the regex solution only works because the names are %presented in a predicable pattern, and would not be valid outside of this dataset
Part of the difficulty in parsing the data accurately was ensuring speech spoken by one person was always attributed to that person, even though the references to that person may use multiple versions of their name. In order to correctly attribute speech to the speaker, without duplicating references to them, a method of NLP called "Name Disambiguation" must be employed.

Name Disambiguation is the method of identifying proper names in text, and recognizing when two proper names refer to the same subject or person.\cite{Wacholder} Many difficulties exist for such a task, as names can come in many forms. Proper nouns can often refer to multiple things. \emph{Johnson and Sons} might refer to a business by that name; two people with the surnames \emph{Johnson} and \emph{Sons}; or someone called \emph{Johnson} and their male children. In this example, the context of the sentence the name appears in may provide clues to which it is, but this is not always an option.

Thankfully, this project only needs to be able to recognize the names of the Members of Parliament mentioned in the Hansard Dataset, which displays more structure in the way it names people than normal human speech would.

\begin{figure}[ht]
\includegraphics[width=\textwidth]{dataset_name_example}
\caption{An example from the original dataset, showing that names exist only within \emph{member} tags}
\label{fig:dataset_name_example}
\end{figure}

As can be seen in fig.\ref{fig:dataset_name_example}, the names needed for this project are always contained within a \emph{member} tag. They still contain the full job title at times, but this means that the area the project needs to look for a name is well defined. It can be guaranteed that, if a member tag is encountered, it will contain the name of the member.

The first attempted method of extracting the name from the \emph{member} tag was using the \emph{Named Entity Chunker} from NLTK, which is designed to extract the Named Entities from a piece of text and return them in a list. Using this, the name could be extracted, potentially along with other parts of the title (\emph{The Under-Secretary of State for Trade (Mr. Reginald Eyre)} would be returned as a list of two names, \emph{State for Trade} and \emph{Mr. Reginald Eyre}). The thought was that the actual name desired could be chosen from that list by looking for the item that started with an Honorific, such as \emph{Mr.}, \emph{Mrs.} and other such titles. However, the Named Entity Chunker did not work consistently enough for it to be a viable solution for the name extractor, as it often separated the honorific from the name. Due to this, it could not be reliably used to extract the names, because there was no way to recognize, when it returned multiple names, which referred to the actual person, and which was a part of their job title.

The second method attempted, which was the one settled on for the project, was the use of Regular Expressions to search for the expected name format. This method relies on a lot of assumptions about the organization of the original dataset, but appears to be good enough for the current dataset. The assumptions are as follows:
\begin{itemize}
	\item All Names start with an Honorific (Mr, Mrs, Sir etc)
	\item All Names End with a Surname
	\item The first time a person is seen, their full name and job title, if relevant, are presented
\end{itemize}

Following these assumptions, Regular Expressions could be used to find the honorific at the start of the name, then get everything following it until either the end of the text, or a piece of punctuation not commonly used in names, such as a bracket.
\begin{figure}[ht]
\includegraphics[width=\textwidth]{extract_name_code_example}
\caption{Extract of code from the Name Extractor Method.}
\label{fig:name_extract_code}
\end{figure}

Fig\ref{fig:name_extract_code} shows the regular expression used to extract a name from a piece of text. It searches for an Honorific to start it off, either \emph{Mr}, \emph{Mrs}, \emph{Dr} or \emph{Sir}. Once it find one of these honorifics it gets everything after it that is not a punctuation mark listed, as shown by the \verb|[^{}\\\n]+| part at the end of the regular expression. The \verb|{}| brackets in that part are replaced with the string called \emph{punctuation}, generated by the string package, so that it becomes a list of all punctuation possible, including new line characters.  

\subsection{Name Matching}
\label{sec:imp_name_match}
Once names can be reliably extracted from the source text, a method of comparing two names to see if they referred to the same person had to be developed. This becomes a very complicated issue, simplified only slightly by the assumptions mentioned previously.

\begin{table}[ht!]
\centering
\begin{tabular}{|c c c|}
Name One & Name Two & Same Person? \\
\hline
Mr. Adam Neaves  & Mr. Adam Neaves & True \\
Mr. A. Neaves    & Mr. Adam Neaves & True \\
Dr. Adam Neaves  & Mr. Adam Neaves & False, wrong Honorific \\
Mr. B. Neaves    & Mr. Adam Neaves & False, wrong First Name \\
Adam Neaves      & Mr. Adam Neaves & True, despite missing honorific \\
Mr. A. B. Neaves & Mr. Adam Neaves & True, though slightly ambiguous \\
Mr. A. B. Neaves & Mr. Neaves      & True, though again ambiguous    \\
\end{tabular}
\caption{Table showing the different ways names might or might not refer to the same person}
\label{tbl:name_match}
\end{table}

For instance, as shown in table \ref{tbl:name_match}, first names might be shortened to just an initial, or even fully removed. Honorifics are not guaranteed to be present, but are very important if they are, as two different names may differ from only that.

The implemented algorithm for this project follows the same assumptions mentioned in section \ref{sec:imp_name_disamb}, and is designed to allow for some false negatives (wherein two names that \emph{do} refer to the same person might not appear as the same person) to avoid any false positives at all. This is because it was desicided that speech accidentally attributed to the wrong person would be worse than accidentally having duplicate references to a person, since a human reader can likely see the connection between \emph{Mr. Adam Neaves} and \emph{Mr. A Neaves}, but there would be no way for them to know that some speech was attributed to the wrong person. The basic algorithm implemented is as shown in Algorithm \ref{lst:name_match}.
\begin{lstlisting}[float=ht,
				   caption={Pseudocode representing the name matching method},
				   label={lst:name_match}]
if BOTH NAMES ARE EXACTLY THE SAME
	return True
SPLIT BOTH NAMES INTO COMPONENT WORDS
for EACH NAME
	if NAME CONTAINS 3 WORDS
		FIRST WORD IS HONORIFIC
		SECOND WORD IS FORENAME
		THIRD WORD IS SURNAME
	else
		FIRST WORD IS HONORIFIC
		LAST WORD IS SURNAME
		IGNORE ANYTHING ELSE
if FORENAME ONE and FORENAME TWO BOTH EXIST
	FORNAME_MATCH = FORNAME ONE == FORNAME TWO
else
	FORNAME_MATCH = True
SURNAME_MATCH = SURNAME ONE == SURNAME TWO
HONORIFIC_MATCH = HONORIFC ONE == HONORIFIC TWO

if SURNAME_MATCH, HONORIFIC_MATCH and FORENAME_MATCH ARE True
	return true
else return False
\end{lstlisting}

This method does work so long as the assumptions in Section \ref{sec:imp_name_disamb} hold true. It would not be a valid method of matching names in a more generalized setting where the formatting and appearance of names would vary wildly.

\section{Manual Annotation Tool}
\label{sec:imp_annotation_tool}